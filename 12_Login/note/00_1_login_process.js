// 로그인 처리 과정

// 1. 기본적인 로그인 방법

//          브라우저
//              이메일, 비밀번호 입력창
//              로그인 버튼

//          백엔드
//              loginUser API
//              fetchUser API

//          데이터베이스
//              회원 테이블: 번호, 이메일, 비밀번호, 이름

//      로그인 과정

//          1) 브라우저에서 이메일, 비밀번호 입력 후 로그인버튼 클릭
//          2) 백엔드 서버로 loginUser API 요청 보냄
//          3) 백엔드가 이 이메일과 비밀번호가 DB에 존재하는지 확인
//          4-1) 이메일, 비밀번호가 없다면 에러 throw
//          4-2) 이메일, 비밀번호가 있다면 백엔드 컴퓨터의 메모리(== 세션)에
//              로그인 아이디(세션 아이디) 와 이메일을 저장
//          5) 세션 아이디를 브라우저에 전달
//          6) 세션 아이디를 브라우저의 쿠키, 로컬 스토리지, 세션 스토리지 등
//              브라우저의 저장 공간에 저장
//              => 브라우저에 저장된 세션 아이디로 회원정보조회, 결제하기 등 API 요청 보냄

//      회원정보 조회 과정

//          1) 앞의 로그인 과정을 거침
//          2) fetchUser API와 함께 쿠키에 있는 세션 아이디를 같이 요청으로 보냄
//          3) 해당 세션 아이디가 백엔드 세션(메모리)에 저장되어 있는지 확인
//          4-1) 세션 아이디가 존재하지 않는다면 에러 throw
//          4-2) 세션 아이디가 존재한다면 로그인 확인된 것
//          5) fetchUser 에 대한 회원 정보를 DB에서 받아옴
//          6) 받아온 회원 정보를 fetchUser 응답으로 브라우저에게 돌려줌

//      인증 Authentication

//          이메일과 비밀번호를 백엔드가 전달받고
//          DB에 일치하는 데이터가 있는지 확인하고
//          세션에 세션 아이디를 생성 및 저장하고
//          브라우저에게 세션 아이디를 돌려주고
//          인증받은 세션 아이디를 브라우저의 저장소(쿠키 등)에 저장하는 과정

//      인가 Authorization

//          API를 요청할 때 세션 아이디(로그인 증표)를 함께 보내고
//          받은 세션 아이디가 백엔드 세션에 저장되어 있는지 확인하는 과정

//          인가에 성공하고 난 뒤에 API 요청에 대한 처리와 응답을 해줌

//      세션 Session (== 토큰)

//          사용자의 id, pw가 DB에 존재할 때 백엔드가 세션 ID를 발행해줌
//          로그인 토큰 이라고도 함
//          로그인 토큰을 가지고 회원정보 조회, 결제 등의 API를 요청할 수 있음
//          로그인 토큰이 있다면 사용자가 인가되어 해당 API가 처리됨


// 2. 업그레이드된 로그인 방법

//      방법 1 문제점

//          트래픽(사용자)이 늘어날수록 백엔드 컴퓨터의 사양이 모자람
//          백엔드 컴퓨터의 메모리가 한정적이기 때문

//      해결 방법

//          1) 백엔드 컴퓨터의 사양을 높인다 == Scale-Up 방식

//              Scale-Up 방식 문제점
//              : 컴퓨터의 사양을 무한히 높일 수 없음
//                컴퓨터의 사양을 높일 때마다 컴퓨터를 종료시켜야됨

//          2) 백엔드 컴퓨터를 여러 대 둔다 == Scale-Out 방식

//              백엔드 컴퓨터 여러 대로 확장해 동일한 소스코드를 실행
//              많은 사용자가 발생해도 나누어 받을 수 있음

//              Scale-Out 방식 문제점
//              : 사용자 A가 1번 백엔드 컴퓨터에서 인증을 했는데
//                2번 백엔드 컴퓨터에 API 요청을 보냄 => 인가 안됨

//              백엔드 컴퓨터가 특정 상태(세션)를 가지고 있음
//              => Stateful

//          3) Scale-Out 방식으로 하되 세션 테이블을 DB에 둔다

//              Stateless
//              : 백엔드 컴퓨터가 특정 상태를 가지지 않는 것
//                세션을 직접 가지고 있지 않는 것을 의미

//      결론

//          메모리의 세션을 DB의 세션 테이블로 분리해
//          백엔드 컴퓨터를 Stateless 로 만들어
//          Scale-Out 방식을 사용할 수 있게 됨


// 3. 더 업그레이드된 로그인 방법

//      방법 2 문제점

//          세션을 DB에 두고 백엔드를 확장해서 하나의 DB에 접근하더라도
//          트래픽이 늘어나면 DB에서 병목 현상이 발생할 수 있음

//          해결 방법으로 DB를 여러 대로 둔다고 하면
//          완전히 동기화되는 DB 여러 대를 두는 것은 시간과 비용이 많이 듬

//      Partitioning (파티셔닝)
//          DB를 나누는 방식

//      수직 파티셔닝

//          DB를 수직으로 나누는 방식
//          전체 컬럼을 일부 컬럼으로 구성된 여러 개의 테이블로 나눔

//          정규화랑 같은거 아냐?
//              정규화랑 거의 비슷하지만 의도가 다름
//              정규화는 중복을 줄이기 위해 테이블을 의미에 따라 분리하는 것
//              파티셔닝은 데이터 크기를 줄이기 위해 테이블을 분리하는 것

//          장점
//              특정 레코드의 일부 컬럼만 조회하고 싶어도 모든 컬럼이 메모리에
//              올라오게 되는데 이것을 방지할 수 있음

//              자주 사용되는 컬럼끼리 묶으면 DB에서 데이터를 조회할 때 효율적

//      수평 파티셔닝

//          DB를 수평으로 나누는 방식
//          전체 레코드를 일부 레코드로 구성된 여러 개의 테이블로 나눔
//          예를 들면 1~1000번 회원, 1001~1000번 회원, 1000명씩 분리하는 것

//          Sharding (샤딩)
//              수평으로 분리한 테이블을 각각 다른 DB에 담는 것
//              500번 회원의 요청은 1번 DB로, 1300번 회원의 요청은 2번 DB로 보냄


// 4. 더 빨라진 로그인 방법 => 현재까지 사용되는 방법

//      방법 3 문제점

//          수평 파티셔닝과 샤딩으로 병목 현상은 줄어들었으나, 
//          인가를 할 때마다 세션 테이블에 있는지 확인해야 함

//          => 디스크에 접근하는 양 (DISK I/O)이 많아짐
//          => 느림!

//      Redis DB 사용

//          디스크에 저장하지 않는 데이터베이스
//          데이터를 메모리에 저장함 => 속도가 빠름
//          하지만 영구 저장은 아님!

//          => 세션 테이블은 Redis에 저장하자

//      인증(Authentication) 과정

//          1) 브라우저에서 loginUser API 요청과 함께 email, password를 보냄
//          2) DB에서 일치하는 회원 정보 데이터가 있는지 확인
//          3) 세션 ID를 생성해 DB의 Redis에 저장 
//             => 백엔드가 상태를 가지지 않는 Stateless 유지
//          4) Redis에 저장한 세션 ID를 브라우저에 응답
//          5) 백엔드로부터 받은 세션 ID를 브라우저 저장소(쿠키)에 저장

//      인가(Authorization) 과정

//          1) 브라우저에서 사용자 정보가 필요한 API 요청과 함께 세션 ID를 보냄
//          2) DB의 Redis에서 일치하는 세션 ID가 있는지 확인
//          3) API 요청을 보고 요청한 내용을 처리해서 브라우저로 응답


// 5. 더 더 빨라진 로그인 방법 => 현재까지 사용되는 방법 2

//      방법 4 문제점

//          인가가 필요한 요청이 올 때마다 Redis에 계속 접근해야 함
//          API 요청 한번에 DB에 최소 두번 접속해야 함 (인가 1회, 요청 처리 1회)
//          => Redis 를 빼는 방법이 없을까?

//      JWT 토큰

//          JSON Web Token
//          세션 객체를 웹에서 사용하기 위해 토큰으로 만들어 사용
//          Redis에 저장해야할 세션 객체를 암호화해 브라우저에게 토큰으로 전송
//          인가 요청이 오면 토큰을 복호화해 인증 정보를 확인, 인가 처리

//      인증(Authentication) 과정

//          사용자의 id/pw가 DB에 존재하면 세션에 저장할 데이터(이메일:a@a.a, 인증:true)를
//          암호화 시키고, 그 암호화된 데이터를 로그인 토큰으로써 브라우저에게 보냄

//      인가(Authorization) 과정

//          브라우저는 로그인 토큰을 쿠키에 저장하고, 토큰과 함께 인가가 필요한 API를 요청하면
//          백엔드에서 토큰을 복호화해 인증했던 사실을 확인, Redis에 접근하지 않고 인가해줌

//      => 인증 정보를 Redis가 아닌 브라우저에 저장함으로써 인가를 위한 DB 접속을 없앰

//      => 우리가 실습에서 사용할 방식 JWT 토큰 로그인